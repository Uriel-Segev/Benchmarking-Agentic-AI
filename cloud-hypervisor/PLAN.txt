================================================================================
CLOUD HYPERVISOR BENCHMARKING - DETAILED IMPLEMENTATION PLAN
================================================================================

Goal: Replicate the exact same benchmarking pipeline from Benchmarking-Agentic-AI
      but using Cloud Hypervisor instead of Firecracker as the VMM.
      Same terminal-bench tasks, same JSON output format, same display_json_time.py.

Location: ~/Cloud-Hypervisor-Benchmarking/  (NOT inside the Firecracker git repo)


================================================================================
PART 1: UNDERSTANDING THE DIFFERENCES
================================================================================

Firecracker vs Cloud Hypervisor:

  Firecracker                          Cloud Hypervisor
  ----------------------------------------------------------------
  Binary: firecracker                  Binary: cloud-hypervisor
  Config: JSON via --config-file       Config: CLI flags (or REST API)
  API: REST (socket-based)             API: REST (socket-based)
  Boot: direct kernel boot             Boot: direct kernel OR firmware (UEFI)
  Disk: --drives in JSON               Disk: --disk path=<rootfs>
  Net: --network-interfaces in JSON    Net: --net "tap=<tap>,mac=<mac>,ip=<ip>,mask=<mask>"
  Console: ttyS0                       Console: hvc0 (virtio console)
  Kernel: vmlinux (uncompressed)       Kernel: vmlinux (PVH) or bzImage or firmware
  Rootfs: ext4 raw image               Rootfs: ext4 raw image (same!)
  Shutdown: reboot -f (guest)          Shutdown: reboot/poweroff or REST API
  vCPUs: machine-config.vcpu_count     vCPUs: --cpus boot=N
  RAM: machine-config.mem_size_mib     RAM: --memory size=<N>M

Key takeaway: The rootfs format is THE SAME (raw ext4). So setup_base_rootfs.sh
and prepare_task_rootfs.sh can be reused almost as-is. The main changes are in
how the VM is launched (run_task.sh) and networking setup (install script).


================================================================================
PART 2: SCRIPTS TO CREATE
================================================================================

You need these 7 scripts, mirroring the Firecracker ones:

  scripts/
  ├── install_cloud_hypervisor.sh    (NEW - different binary + networking)
  ├── setup_base_rootfs.sh           (COPY from Firecracker, minimal changes)
  ├── prepare_task_rootfs.sh         (COPY from Firecracker, no changes needed)
  ├── run_task.sh                    (REWRITE - different VM launch command)
  ├── run_parallel.sh                (COPY from Firecracker, minimal changes)
  ├── run_scaling.sh                 (COPY from Firecracker, no changes needed)
  └── run_scaling_linear.sh          (COPY from Firecracker, no changes needed)

Also copy over:
  display_json_time.py               (EXACT COPY - same JSON format)
  commands_to_run.txt                (UPDATE paths and commands)


================================================================================
PART 3: SCRIPT-BY-SCRIPT DETAILS
================================================================================


--- SCRIPT 1: install_cloud_hypervisor.sh ---

Purpose: Install cloud-hypervisor binary and set up networking.

Steps:
  1. Download the static binary from GitHub releases:
     URL: https://github.com/cloud-hypervisor/cloud-hypervisor/releases
     File: cloud-hypervisor-static (for x86_64)
     Put in: /usr/local/bin/cloud-hypervisor

  2. Download a kernel for direct boot:
     Cloud Hypervisor needs a PVH-enabled vmlinux OR you can use their
     hypervisor-fw firmware. For apples-to-apples comparison with Firecracker,
     use direct kernel boot with a PVH-compatible vmlinux.

     Option A: Build a PVH kernel (complex)
     Option B: Use hypervisor-fw from:
       https://github.com/cloud-hypervisor/rust-hypervisor-firmware/releases
     Option C: Use the same vmlinux from Firecracker and boot with bzImage
       instead (cloud-hypervisor supports bzImage unlike Firecracker)

     RECOMMENDED: Start with hypervisor-fw for simplicity, then switch to
     direct kernel boot later if you want apples-to-apples boot time comparison.

  3. Download base rootfs:
     SAME as Firecracker — Ubuntu 22.04 ext4 image. Can reuse the same URL:
     https://s3.amazonaws.com/spec.ccfc.min/firecracker-ci/v1.9/x86_64/ubuntu-22.04.ext4

     OR use Ubuntu cloud images:
     https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img
     (needs qemu-img convert to raw)

  4. Set up TAP networking:
     Same concept as Firecracker — create TAP device, assign IP, enable forwarding.

     ip tuntap add dev tap0 mode tap
     ip addr add 192.168.100.1/30 dev tap0
     ip link set tap0 up
     echo 1 > /proc/sys/net/ipv4/ip_forward
     iptables -t nat -A POSTROUTING -o <internet-iface> -j MASQUERADE
     iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
     iptables -A FORWARD -i tap0 -o <internet-iface> -j ACCEPT

     This is basically the same as install_firecracker.sh. You can reuse most
     of the networking logic.

  5. Verify:
     cloud-hypervisor --version
     ls /dev/kvm


--- SCRIPT 2: setup_base_rootfs.sh ---

Purpose: Create or download a base ext4 rootfs.

Changes from Firecracker version:
  - Almost none. The rootfs format is identical (raw ext4).
  - Change WORKDIR from /opt/firecracker to /opt/cloud-hypervisor
  - Same rootfs URL works, or use Ubuntu cloud images.

COPY the Firecracker version and change:
  - WORKDIR="/opt/cloud-hypervisor"
  - Any references to "firecracker" in log messages


--- SCRIPT 3: prepare_task_rootfs.sh ---

Purpose: Mount base rootfs, chroot in, install python/deps, copy task files.

Changes from Firecracker version:
  - Change WORKDIR from /opt/firecracker to /opt/cloud-hypervisor
  - Everything else is identical — it's just manipulating an ext4 image.

COPY the Firecracker version and change:
  - WORKDIR="/opt/cloud-hypervisor"
  - Any references to "firecracker" in log messages


--- SCRIPT 4: run_task.sh (THE BIG ONE) ---

Purpose: Launch a single Cloud Hypervisor VM, wait for task, extract results.

This is where most changes happen. The Firecracker version does:
  1. Create JSON config
  2. Run: firecracker --api-sock <sock> --config-file <json>
  3. Wait for process to exit
  4. Mount rootfs, extract results

For Cloud Hypervisor, replace step 1-2 with:

  cloud-hypervisor \
    --kernel /opt/cloud-hypervisor/hypervisor-fw \
    --disk path=${TASK_ROOTFS} \
    --cpus boot=${VCPU_COUNT} \
    --memory size=${MEM_SIZE_MIB}M \
    --net "tap=${TAP_DEV},mac=${MAC},ip=${TAP_IP},mask=${NETMASK}" \
    --serial tty \
    --console off

  OR with direct kernel boot (if using vmlinux):

  cloud-hypervisor \
    --kernel /opt/cloud-hypervisor/vmlinux \
    --cmdline "console=hvc0 root=/dev/vda1 rw ip=${FC_IP}::${TAP_IP}:${NETMASK}::eth0:off" \
    --disk path=${TASK_ROOTFS} \
    --cpus boot=${VCPU_COUNT} \
    --memory size=${MEM_SIZE_MIB}M \
    --net "tap=${TAP_DEV},mac=${MAC},ip=${TAP_IP},mask=${NETMASK}" \
    --serial tty \
    --console off

  IMPORTANT differences:
  - No --api-sock required (can add --api-socket if you want REST control)
  - No JSON config file — everything is CLI flags
  - Console is hvc0, not ttyS0 (unless you use --serial tty, then ttyS0 works)
  - Disk device shows up as /dev/vda (virtio) not /dev/vda in guest
  - The boot_args/cmdline needs "root=/dev/vda1" (check the partition layout)

  Steps 3-4 (wait for exit, mount rootfs, extract results) are THE SAME as
  Firecracker. The timing extraction logic is identical.

  Key things to keep:
  - HOST_LAUNCH_EPOCH / HOST_VM_EXIT_EPOCH timing
  - Guest timing markers (boot_done, solution_done, etc.)
  - Rootfs mounting and result extraction
  - Timeout handling


--- SCRIPT 5: run_parallel.sh ---

Purpose: Run N VMs in parallel, each with its own rootfs copy and TAP device.

Changes from Firecracker version:
  - Change WORKDIR from /opt/firecracker to /opt/cloud-hypervisor
  - The call to run_task.sh stays the same (it calls the local run_task.sh)
  - TAP device creation is the same
  - Rootfs copying is the same
  - Result extraction is the same

COPY the Firecracker version and change:
  - WORKDIR="/opt/cloud-hypervisor"
  - References to "firecracker" in log messages
  - Make sure it calls the local run_task.sh (uses SCRIPT_DIR, so it will)


--- SCRIPT 6: run_scaling.sh ---

Purpose: Run scaling benchmark at powers of 2.

Changes from Firecracker version: NONE (functionally).
It just calls run_parallel.sh and collects JSON. Copy it and update log messages.

APPLY THE SLURPFILE FIX from run_scaling_linear.sh (the jq argument too long bug).


--- SCRIPT 7: run_scaling_linear.sh ---

Purpose: Run scaling benchmark at linear increments.

Changes from Firecracker version: NONE (functionally).
Same as above — just calls run_parallel.sh. Copy as-is.


================================================================================
PART 4: STEP-BY-STEP IMPLEMENTATION ORDER
================================================================================

Phase 1: Setup
  [ ] Create directory structure:
      ~/Cloud-Hypervisor-Benchmarking/
      ├── scripts/
      ├── results/
      └── charts/

  [ ] Copy these unchanged from Firecracker repo:
      - display_json_time.py
      - scripts/run_scaling.sh (apply slurpfile fix)
      - scripts/run_scaling_linear.sh

Phase 2: Install Script
  [ ] Write install_cloud_hypervisor.sh:
      - Download cloud-hypervisor-static binary
      - Download hypervisor-fw OR vmlinux kernel
      - Download base rootfs
      - Set up TAP networking (reuse Firecracker networking logic)
      - Create /opt/cloud-hypervisor/ directory

Phase 3: Rootfs Scripts
  [ ] Copy setup_base_rootfs.sh, change WORKDIR to /opt/cloud-hypervisor
  [ ] Copy prepare_task_rootfs.sh, change WORKDIR to /opt/cloud-hypervisor

Phase 4: run_task.sh (core work)
  [ ] Rewrite the VM launch section:
      - Replace firecracker JSON config with cloud-hypervisor CLI flags
      - Adjust boot_args (console=hvc0, root=/dev/vda1)
      - Test with a single VM first
  [ ] Keep ALL timing logic identical
  [ ] Keep ALL result extraction logic identical
  [ ] Test: sudo ./scripts/run_task.sh /opt/cloud-hypervisor/rootfs-task.ext4

Phase 5: run_parallel.sh
  [ ] Copy from Firecracker, change WORKDIR
  [ ] Test: sudo ./scripts/run_parallel.sh <rootfs> 4

Phase 6: Scaling
  [ ] Test run_scaling.sh with small count (max 4)
  [ ] Test run_scaling_linear.sh with small count (max 20, step 10)
  [ ] Full scaling run and compare results with Firecracker


================================================================================
PART 5: GOTCHAS AND THINGS TO WATCH OUT FOR
================================================================================

1. KERNEL/FIRMWARE CHOICE
   - hypervisor-fw is easiest to start with but adds firmware overhead
   - For fair boot time comparison with Firecracker, use direct kernel boot
   - The Firecracker vmlinux may NOT work with Cloud Hypervisor (needs PVH support)
   - You may need to build a custom kernel or find a PVH-enabled vmlinux

2. CONSOLE OUTPUT
   - Firecracker uses ttyS0 (serial)
   - Cloud Hypervisor defaults to hvc0 (virtio console)
   - If your guest autorun script writes timing markers to console, make sure
     the boot_args match: use "console=hvc0" or "console=ttyS0" depending on
     how you configure --serial/--console flags

3. DISK DEVICE NAME
   - Firecracker: guest sees /dev/vda
   - Cloud Hypervisor: guest sees /dev/vda (same for virtio-blk)
   - BUT if using firmware boot, partition layout may differ: /dev/vda vs /dev/vda1
   - Check what the rootfs expects in /etc/fstab

4. SHUTDOWN BEHAVIOR
   - Firecracker: "reboot -f" in guest causes process exit
   - Cloud Hypervisor: has ACPI support, so "poweroff" from guest cleanly exits the process
   - "reboot" from guest will RESTART the VM (not exit!) — use "poweroff" instead
   - The autorun script in the rootfs probably uses "reboot -f" — change it to "poweroff"
   - Test this early: if the VM doesn't exit on guest shutdown, your timing logic breaks

5. NETWORKING
   - TAP setup is the same
   - MAC address format in --net flag: "tap=tap0,mac=AA:BB:CC:DD:EE:FF,ip=...,mask=..."
   - Cloud Hypervisor may assign the NIC differently in guest — check with "ip a" inside VM

6. THE SLURPFILE BUG
   - Apply the same fix to run_scaling.sh that was applied to run_scaling_linear.sh
   - Use --slurpfile instead of --argjson for the runs array in jq

7. TIMING COMPARISON
   - Once both pipelines work, you can run the SAME task on both VMMs and compare
   - Use display_json_time.py on both results to visualize side by side
   - The JSON format is identical, so you could even write a comparison script later


================================================================================
PART 6: COMMANDS TO RUN (once scripts are written)
================================================================================

# On node0 (or whatever machine):

# One-time setup
chmod +x Cloud-Hypervisor-Benchmarking/scripts/*.sh
sudo Cloud-Hypervisor-Benchmarking/scripts/install_cloud_hypervisor.sh
sudo Cloud-Hypervisor-Benchmarking/scripts/setup_base_rootfs.sh

# Prepare task
sudo Cloud-Hypervisor-Benchmarking/scripts/prepare_task_rootfs.sh \
  terminal-bench/original-tasks/hello-world

# Single VM test
sudo Cloud-Hypervisor-Benchmarking/scripts/run_task.sh \
  /opt/cloud-hypervisor/rootfs-task.ext4

# Scaling benchmarks
sudo Cloud-Hypervisor-Benchmarking/scripts/run_scaling.sh \
  /opt/cloud-hypervisor/rootfs-task.ext4 64 \
  --output scaling_ch_64.json --cooldown 10

sudo Cloud-Hypervisor-Benchmarking/scripts/run_scaling_linear.sh \
  /opt/cloud-hypervisor/rootfs-task.ext4 100 \
  --output scaling_ch_linear_100.json --cooldown 10

# Copy results to local machine
scp -i ~/.ssh/id_ed25519 Uriel@128.110.219.161:~/scaling_ch_64.json .

# Display
python display_json_time.py scaling_ch_64.json


================================================================================
RESOURCES
================================================================================

- Cloud Hypervisor GitHub: https://github.com/cloud-hypervisor/cloud-hypervisor
- Quick Start: https://www.cloudhypervisor.org/docs/prologue/quick-start/
- Build Docs: https://github.com/cloud-hypervisor/cloud-hypervisor/blob/main/docs/building.md
- Firmware: https://github.com/cloud-hypervisor/rust-hypervisor-firmware/releases
- Getting Started Tutorial: https://jakerunzer.com/posts/getting-started-with-cloud-hypervisor
- 2026 Guide: https://northflank.com/blog/guide-to-cloud-hypervisor

INSTALL COMMANDS (for quick reference):
  CH_VERSION="v43.0"  # check releases page for latest
  wget https://github.com/cloud-hypervisor/cloud-hypervisor/releases/download/${CH_VERSION}/cloud-hypervisor-static
  chmod +x cloud-hypervisor-static
  sudo mv cloud-hypervisor-static /usr/local/bin/cloud-hypervisor

  # Firmware
  wget https://github.com/cloud-hypervisor/rust-hypervisor-firmware/releases/download/0.4.2/hypervisor-fw

ADDITIONAL NOTES:
  - Cloud Hypervisor supports qcow2 AND raw images (Firecracker only supports raw)
  - Memory size in JSON config is in BYTES (not MiB like Firecracker)
  - --serial tty + console=ttyS0 OR --console tty + console=hvc0 (don't mix both)
  - Sending SIGTERM to cloud-hypervisor process does a clean shutdown
  - Supports huge pages for better perf: --memory size=1024M,hugepages=on
  - No built-in jailer (unlike Firecracker) — use external isolation if needed
